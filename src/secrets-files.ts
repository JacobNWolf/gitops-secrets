import fs from 'node:fs';
import path from 'node:path';
import * as secrets from './secrets';
import { EnvTarget } from './types';

const SECRETS_FOLDER = path.join(__dirname, '../.secrets');
const DEFAULT_JS_PATH = path.join(SECRETS_FOLDER, '.secrets.enc.js');
const DEFAULT_JSON_PATH = path.join(SECRETS_FOLDER, '.secrets.enc.json');

if (!fs.existsSync(SECRETS_FOLDER)) {
   fs.mkdirSync(SECRETS_FOLDER, { recursive: true });
}

/**
 * Encapsulate encrypted secrets in a JS module for easy runtime access.
 * Use {options.path} to output module locally for when package level storage or non-literal imports are disallowed.
 * Use {options.cipherTextOnly} to limit the JS file to only exporting `CIPHER_TEXT`.
 * @param {<Record<string, any>>} payload
 * @param {{path: string | null, cipherTextOnly: boolean}} options
 */
// biome-ignore lint/suspicious/noExplicitAny: Want to keep this flexible
async function build(payload: Record<string, any>, options = { path: null as string | null, cipherTextOnly: false }) {
   const cipherText = await secrets.encrypt(JSON.stringify(payload));
   const filePath = options.path ? path.resolve(options.path) : DEFAULT_JS_PATH;
   const packageType = process.env.npm_package_type === 'module' ? 'esm' : 'cjs';
   const format = filePath === DEFAULT_JS_PATH ? 'cjs' : packageType;
   const lines = ['This file was auto-generated by @jacobwolf/gitops-secrets'];

   if (format === 'esm') {
      if (!options.cipherTextOnly) {
         lines.push(`import secrets from '@jacobwolf/gitops-secrets/no-fs';`);
         lines.push(`const CIPHER_TEXT = ${JSON.stringify(cipherText)};`);
         lines.push('const loadSecrets = () => secrets.loadSecretsFromCipher(CIPHER_TEXT);');
         lines.push('export { CIPHER_TEXT, loadSecrets };');
      } else {
         lines.push(`const CIPHER_TEXT = ${JSON.stringify(cipherText)};`);
         lines.push('export { CIPHER_TEXT };');
      }
   }

   if (format === 'cjs') {
      if (!options.cipherTextOnly) {
         lines.push(`const secrets = require('@jacobwolf/gitops-secrets/no-fs');`);
         lines.push(`const CIPHER_TEXT = ${JSON.stringify(cipherText)};`);
         lines.push('const loadSecrets = () => secrets.loadSecretsFromCipher(CIPHER_TEXT);');
         lines.push('module.exports = { CIPHER_TEXT, loadSecrets };');
      } else {
         lines.push(`const CIPHER_TEXT = ${JSON.stringify(cipherText)};`);
         lines.push('module.exports = { CIPHER_TEXT };');
      }
   }

   writeFile(filePath, lines.join('\n'));
}

/**
 * Encrypt JSON-serializable payload to a static file.
 * @param {<Record<string, any>>} payload
 * @param {{path: string | null}} [options={path: null}]
 */
// biome-ignore lint/suspicious/noExplicitAny: Want to keep this flexible
async function encryptToFile(payload: Record<string, any>, options = { path: null as string | null }) {
   const cipherText = await secrets.encrypt(JSON.stringify(payload));
   const filePath = options.path ? path.resolve(options.path) : DEFAULT_JSON_PATH;
   writeFile(filePath, cipherText);
}

/**
 * Decrypt JSON payload to object with option to merge with process.env.
 * @param {string} filePath
 * @returns
 */
async function decryptFromFile(filePath: string) {
   const newFilePath = filePath ? path.resolve(filePath) : DEFAULT_JSON_PATH;

   try {
      const cipherText = fs.readFileSync(newFilePath, { encoding: 'utf-8' });
      const decryptedText = await secrets.decrypt(cipherText);
      const payload = JSON.parse(decryptedText);
      return {
         ...payload,
         mergeSecrets: () => secrets.mergeSecrets(payload, EnvTarget.PROCESS),
      };
   } catch (error) {
      throw new Error(`Failed to decrypt file ${newFilePath}: ${error}`);
   }
}

function writeFile(filePath: string, fileContents: string) {
   try {
      fs.writeFileSync(filePath, fileContents, { encoding: 'utf-8' });
   } catch (error) {
      throw new Error(`Failed to write file ${filePath}: ${error}`);
   }
}

function loadSecrets() {
   return require(DEFAULT_JS_PATH).loadSecrets();
}

export { build, encryptToFile, decryptFromFile, loadSecrets };
